# 8.transcation 本地事务消息表

本文介绍 `Maomi.MQ.Transaction` 的本地事务消息表设计、状态流转和落地用法。这里保留 `transcation` 命名用于和现有编号文档保持一致。

## 1. 解决的问题

在传统“先写业务库、再发 MQ”流程中，如果两步之间发生异常，会出现数据不一致：

- 业务写入成功，但消息没发出去。
- 消息发出去了，但业务事务回滚。

`Maomi.MQ.Transaction` 使用 Outbox + Inbox Barrier，把“业务数据”和“消息状态”统一在本地数据库事务内处理，最终达到“最终一致 + 消费幂等”。

## 2. 两张核心表

默认表名：

- 发布侧 Outbox：`mq_publisher`
- 消费侧 Inbox Barrier：`mq_consumer`

建表 SQL 在仓库 `asserts` 目录：

- `asserts/transaction-mysql-default-create-table.sql`
- `asserts/transaction-sqlserver-default-create-table.sql`
- `asserts/transaction-postgres-default-create-table.sql`

你也可以在配置中开启自动建表：

```csharp
builder.Services.AddMaomiMQTransaction(options =>
{
    options.ProviderName = TransactionProviderNames.MySql;
    options.Connection = _ => new MySqlConnection(connectionString);
    options.AutoCreateTable = true;
});
```

## 3. Outbox 表字段含义（mq_publisher）

高频关键字段：

- `message_id`：消息唯一 ID，主键。
- `exchange`、`routing_key`：目标路由信息。
- `message_header`、`message_body`：序列化后的消息头/体。
- `status`：消息状态。
  - `0 Pending`
  - `1 Processing`
  - `2 Succeeded`
  - `3 Failed`
- `retry_count`、`next_retry_time`：重试控制。
- `lock_id`、`lock_time`：后台扫描进程抢锁信息。
- `last_error`：最近一次发送失败原因。

运行机制：

1. 业务事务中写业务表 + 插入 `mq_publisher(status=Pending)`。
2. 提交后，后台服务轮询 Outbox。
3. 抢锁成功后发送 MQ。
4. 成功改 `Succeeded`；失败改 `Failed` 或回到待重试。

## 4. Inbox 表字段含义（mq_consumer）

高频关键字段：

- `consumer_name` + `message_id`：联合主键，保证同一个消费者对同一消息只进一次主流程。
- `status`：消费状态（同上）。
- `message_header`、`exchange`、`routing_key`：用于审计和问题定位。
- `lock_id`、`lock_time`：处理中的锁标记。
- `last_error`：消费失败信息。

运行机制：

1. 消费者收到消息后先 `EnterAsync` 写/读 Barrier 记录。
2. 如果不是 `Entered`，说明重复消息或已有处理结果，直接跳过。
3. `Entered` 时执行业务事务。
4. 业务成功后调用 `MarkSucceededAsync`，完成状态落库。

## 5. 推荐使用流程

发布端（生产消息）：

1. 开启数据库事务。
2. 写业务数据。
3. 调用 `ITransactionOutboxService.RegisterAutoAsync` 写 Outbox。
4. 提交数据库事务。
5. 由后台服务异步投递到 MQ。

消费端（处理消息）：

1. 开启数据库事务。
2. 调用 `ITransactionBarrierService.EnterAsync`。
3. 仅当结果为 `Entered` 时执行业务。
4. 调用 `MarkSucceededAsync`。
5. 提交数据库事务。

## 6. 关键配置建议

建议按业务峰值调整以下参数（`MQTransactionOptions`）：

- `Publisher.ScanDbInterval`：Outbox 轮询间隔。
- `Publisher.MaxFetchCountPerLoop`：每轮拉取条数。
- `Publisher.MaxRetry`：失败最大重试次数。
- `Publisher.LockTimeout`：发布锁超时。
- `Consumer.ProcessingTimeout`：消费处理超时。
- `Publisher.DisplayMessageText`：生产环境建议 `false`。

如果你改了表名：

- `Publisher.TableName`
- `Consumer.TableName`

请同步调整建表脚本和监控 SQL。

## 7. 常见排障

- `mq_publisher` 长时间有 `Pending`：
  - 检查发布后台服务是否启动。
  - 检查 MQ 连接是否正常。
  - 看 `last_error` 是否持续有相同异常。
- `mq_consumer` 大量 `Processing`：
  - 可能消费者崩溃或超时未回写状态。
  - 核对 `ProcessingTimeout` 是否合理。
- 重复消费：
  - 确认业务代码是否在 `EnterResult == Entered` 才执行。
  - 确认业务和 `MarkSucceededAsync` 在同一数据库事务内。

## 8. 和 EF Core 搭配

可直接将 EF Core 当前事务传给 Outbox/Barrier 服务，无需改库内核心流程。  
完整代码见：`src/transactions/EFCore.md`。

